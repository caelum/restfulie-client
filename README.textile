h1. Quit pretending

CRUD through HTTP is a good step forward to using resources and becoming RESTful, another step further into it is to make use of hypermedia based services and this gem allows you to do it really fast.

h2. Why would I use restfulie?

1. Easy --> writing hypermedia aware resource based clients
2. Easy --> hypermedia aware resource based services
3. Small -> it's not a bloated solution with a huge list of APIs
4. HATEOAS --> clients you are unaware of will not bother if you change your URIs
5. HATEOAS --> services that you consume will not affect your software whenever they change part of their flow or URIs

h1. Restfulie: client-side

Example on accessing a resource and its services through the restfulie API:

<pre>
order = Order.from_web resource_uri

puts "Order price is #{order.price}"

order.pay payment                        # sends a post request to pay this order

order.cancel                             # sends a delete request
</pre>

h1. Restfulie: server-side

This is a simple example how to make your state changes available to your resource consumers:

<pre>
class Order < ActiveRecord::Base
  def following_transitions
    transitions = []
    transitions << [:show, {}]
    transitions << [:destroy, {}] if can_cancel?
    transitions << [:pay, {:id => id}] if can_pay?
    transitions << [:show, {:controller => :payments, :payment_id => payment.id }] if paid?
    transitions
  end
end
</pre>

*Do not forget to create a migration with a string field named status for your resource:*

<pre>
scripts/generate migration add_status_to_order	
</pre>

Content:

<pre>
class AddStatusToOrder < ActiveRecord::Migration
  def self.up
    add_column :orders, :status, :string
	Order.all.each do |order|
		order.status = "unpaid"
		order.save
	end
  end

  def self.down
    remove_column :orders, :status
  end
end
</pre>

Or simply define a status reader and writer on your own.



h2. Restfulie server-side: state machine

For those willing to implement a more complex or advanced state machine, you can use the dsl-like api:

<pre>
class Order < ActiveRecord::Base
  state :unpaid, :allow => [:latest, :pay, :cancel]
  state :cancelled, :allow => :latest

  transition :latest, {:action => :show}
  transition :cancel, {:action => :destroy}, :cancelled
  transition :pay, {}, :preparing
end
</pre>

h2. Installing

Just add in your environment.rb the following line:

<pre>
config.gem "restfulie", :source => "http://gemcutter.org"
</pre>

And then execute:
<pre>rake gems:install</pre>

or, if you prefer to install it as a plugin:

<pre>script/plugin install git://github.com/caelum/restfulie.git</pre>

h2. Typical hypermedia aware example

Trying to follow the definition of a RESTful application supporting resources with hypermedia content, a resource would be:

<pre>
<order>
	<product>basic rails course</product>
	<product>RESTful training</product>
	<atom:link rel="refresh" href="http://www.caelum.com.br/orders/1" xmlns:atom="http://www.w3.org/2005/Atom"/>
	<atom:link rel="update" href="http://www.caelum.com.br/orders/1" xmlns:atom="http://www.w3.org/2005/Atom"/>
	<atom:link rel="pay" href="http://www.caelum.com.br/orders/1/pay" xmlns:atom="http://www.w3.org/2005/Atom"/>
	<atom:link rel="destroy" href="http://www.caelum.com.br/orders/1" xmlns:atom="http://www.w3.org/2005/Atom"/>
</order>
</pre>

h2. Client Usage

One should first acquire the representation from the server through your common GET request and process it through the usual from_* methods:
<pre>xml = Net::HTTP.get(URI.parse('http://www.caelum.com.br/orders/1'))
order = Order.from_xml(xml)</pre>
or use the restfulie *from_web*:
<pre>order = Order.from_web 'http://www.caelum.com.br/orders/1'</pre>

And now you can invoke all those actions in order to change your resource's state:

<pre>
order.refresh
order.update
order.destroy
order.pay
</pre>

Note that:
* refresh is get
* update is put (and you have to put everything back)
* destroy is delete
* pay (unknown methods) is post

h2. Resource format support

Restfulie currently supports full xml+atom, partial xml+rel and will soon expand its support to json+links.


h2. Help

If you are looking for or want to help, let us know at the mailing list:

"http://groups.google.com/group/restfulie":http://groups.google.com/group/restfulie

h2. Client-side configuration: how to customize your request

h3. HTTP verbs

By default, restfulie uses the following table:

* destroy, cancel and delete send a DELETE request
* update sends a PUT request
* refresh, reload, show, latest sends a GET request
* other methods sends a POST request

If you want to use a custom http verb in order to send your request, you can do it by setting the optional string 'method':

<pre>order.update(:method=>"post")</pre>

h3. Request parameters

If you want to send extra parameters, you can do it through the *data* parameter:

<pre>order.pay(:data => {:payment => my_payment})</pre>

The parameters will be serialized either to xml or json according to which format was used to deserialize the order at first place.

h3. Executing another GET request

If your method executes another GET request, it will automatically deserialize its result as:

<pre>order = Order.from_web order_uri
payment = order.check_payment_info</pre>

If you want to parse the response yourself, instead of receiving just the final deserialized object, you can do it by passing a body to your method

<pre>order = Order.from_web order_uri
successful = order.check_payment_info do |response|
  return response.code==200
end</pre>

h2. Server-side configuration

There are two different approaches that can be combined to create a full hypermedia aware resource based service, including awareness of its states and transitions.

h3. The following available transitions method

The most easy way to use restfulie is to write the *following_transitions* method.
It should return a list of possible transitions, where each transition is identified by an array of its name and definition.

The next example shows how to define a transition which will map to the current controller, action show:

<pre>
def following_transitions
  transitions = []
  transitions << [:show, {}]
  transitions
end
</pre>

Which will generate an hyperlink as

<pre><atom:link rel="show" rel="http://yourserver/orders/15" /></pre>

h3. Customizing the rel name

You can also override the action used, but still keep the rel

<pre>
def following_transitions
  transitions = []
  transitions << [:cancel, { :action => :destroy }]
  transitions
end
</pre>

Which will generate an hyperlink as

<pre><atom:link rel="cancel" rel="http://yourserver/orders/15" /></pre>

h3. Example

A full example showing all capabilities of this method follows:

<pre>
def following_transitions
  transitions = []
  transitions << [:show, {}]
  transitions << [:destroy, {}] if can_cancel?
  transitions << [:pay, {:id => id}] if can_pay?
  transitions << [:show, {:controller => :payments, :payment_id => payment.id }] if paid?
  transitions
end
</pre>

h2. Defining the state machine and its transitions

The second way of defining your available transitions is to explicitely define the states and transitions.

By using this approach, one has to define a new column named *status* in a database migration file.

The first step involves defining all your states, each one with its own name and possible transitions, as:

<pre>
	state :state_name, :allow => [ :first_transition_name, :second_transition_name]
</pre>

The following example shows all possible states for an order:

<pre>
class Order < ActiveRecord::Base
	state :unpaid, :allow => [:latest, :pay, :cancel]
	state :cancelled, :allow => :latest
	state :received, :allow => [:latest, :check_payment_info]
	state :preparing, :allow => [:latest, :check_payment_info]
	state :ready, :allow => [:latest, :receive, :check_payment_info]
end
</pre>

Now its time to define which controller and action each transition invokes, in a much similar way to
the transition definitions in the following_transitions method:

<pre>
class Order < ActiveRecord::Base
end
</pre>

Once a transition has been given a name, its name can be used in the following_transitions method also.
The next example does not configure the transition because it was already defined, only adding it to the
list of available transition whenever the *can_pay?* method returns true:

<pre>
class Order < ActiveRecord::Base
	transition :pay, {:action => pay_this_order, :controller => :payments}, :preparing

	def following_transitions
	  transitions = []
	  transitions << :pay if can_pay?
	  transitions
	end
end
</pre>

Note that whenever one defines a transition, there is a third - optional - argument, this is the
transition's target's state. Whenever the method *order.pay* method is invoked in the *server*, it will
automatically change the order's status to *preparing*.

You can download the server side example to see the complete code.

The last usage of the transition definition involves passing a block which receives the element in which
the transition URI's is required. The block should return all the necessary information for retrieving the URI, now having access to your element's instance variables:

<pre>
class Order < ActiveRecord::Base
	transition :check_payment_info do |order|
	   {:controller => :payments, :action => :show, :order_id => order.id, :payment_id => order.payments[0].id, :rel => "check_payment_info"}
	end
end
</pre>
  
h3. Using xml+rel links instead of atom links

Atom is everywhere and can be consumed by a number of existing tools but if your system wants to supply its
services through commons rel+link xml as

<pre>
	<order>
		<product>basic rails course</product>
		<product>RESTful training</product>
		<refresh>http://www.caelum.com.br/orders/1</refresh>
		<update>http://www.caelum.com.br/orders/1</update>
		<pay>http://www.caelum.com.br/orders/1/pay</pay>
		<destroy>http://www.caelum.com.br/orders/1</destroy>
	</order>
</pre>

You can do it by passing the *use_name_based_link* argument:

<pre>
    order.to_xml(:controller => my_controller, :use_name_based_link => true)
</pre>

h2. Team

Restfulie was created and is maintained within Caelum by

Projetct Founder
* "Guilherme Silveira":mailto:guilherme.silveira@caelum.com.br

Active Commiters
* "Caue Guerra":mailto:caue.guerra@gmail.com
* "Guilherme Silveira":mailto:guilherme.silveira@caelum.com.br

Contributors
* Diego Carrion
* Leandro Silva
* Gavin-John Noonan

h2. Try it online

We have a live example of a server implementation using a resource+hypermedia course ordering system available.

Follow the steps below to try out the system:

* "Access the server system":http://restfulie-test.heroku.com
* Create a couple of trainings
* Create an order
* Access the order listing and retrieve its xml link

And now you can try the restfulie client api through a simple and generic resource+hypermedia client application:

* "Access the client system":http://restfulie-client.heroku.com
* Enter your order uri
* Check your order information which was retrieved and all available actions

Now you can either:

* *latest* - refresh your order information  _order.latest_
* *cancel* - cancel your order (dead end!) _order.destroy_
* *pay* - pay for your order, and don't forget to send your (fake) credit card information _order.pay(payment)_
* *check_payment_info* - after paying you can check the payment information stored at the server _order.check_payment_info_

In order to pay do not forget to send the parameter *payment* with a value as

<pre>
 <payment>
   <amount>15</amount>
   <cardholder_name>Guilherme Silveira</cardholder_name>
   <card_number>123456789012</card_number>
   <expiry_month>12</expiry_month>
   <expiry_year>12</expiry_year>
 </payment>
</pre>


h3. Sources

"Client":http://github.com/caelum/restfulie-client
"Server":http://github.com/caelum/restfulie-test


h2. License

/***
 * Copyright (c) 2009 Caelum - www.caelum.com.br/opensource
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * 	http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
